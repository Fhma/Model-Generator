<?xml version="1.0" encoding="ISO-8859-1"?>
<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:atl="http://www.eclipse.org/gmt/2005/ATL" xmlns:ocl="http://www.eclipse.org/gmt/2005/OCL">
  <atl:Module location="11:1-34:2" name="Tree2List">
    <commentsBefore>-- @name Tree structure to List structure</commentsBefore>
    <commentsBefore>-- @version 1.0</commentsBefore>
    <commentsBefore>-- @domains </commentsBefore>
    <commentsBefore>-- @authors Cyril Faure</commentsBefore>
    <commentsBefore>-- @date 01/06/2007</commentsBefore>
    <commentsBefore>-- @description &quot;toy example&quot; of model transformation usually made with a DFS (Depth First Search) imperative algorithms</commentsBefore>
    <commentsBefore>-- @see http://en.wikipedia.org/wiki/Depth-first_search</commentsBefore>
    <commentsBefore>-- @path MMTree=/Tree2List/metamodels/MMTree.ecore</commentsBefore>
    <commentsBefore>-- @path MMElementList=/Tree2List/metamodels/MMElementList.ecore</commentsBefore>
    <libraries location="14:1-14:17" name="Lib4MMTree">
      <commentsAfter>-- we want to process the tree via DFS and create an ordered list containing :</commentsAfter>
      <commentsAfter>-- all big leafs, then all medium leafs, then all small leafs. We add the</commentsAfter>
      <commentsAfter>-- constraint we want all three &quot;sublists&quot; to be ordered on the DFS traversal order</commentsAfter>
      <commentsAfter>-- Note : the nodes (other than the tree root) are not kept in the destination model</commentsAfter>
      <commentsAfter>-- The transformation is done with only one matched rule. For each element of its elements reference, we create a MMElementList!CommonElement. </commentsAfter>
      <commentsAfter>-- Each element of this list is computed via a distinct keyword which creates a CommonElement for each Leaf of a list we compute via an helper.</commentsAfter>
    </libraries>
    <inModels location="12:37-12:51" name="aTree" metamodel="/2"/>
    <outModels location="12:8-12:31" name="elmList" metamodel="/1"/>
    <elements xsi:type="atl:MatchedRule" location="23:1-34:2" name="TreeNodeRoot2RootElement">
      <commentsBefore>-- we want to process the tree via DFS and create an ordered list containing :</commentsBefore>
      <commentsBefore>-- all big leafs, then all medium leafs, then all small leafs. We add the</commentsBefore>
      <commentsBefore>-- constraint we want all three &quot;sublists&quot; to be ordered on the DFS traversal order</commentsBefore>
      <commentsBefore>-- Note : the nodes (other than the tree root) are not kept in the destination model</commentsBefore>
      <commentsBefore>-- The transformation is done with only one matched rule. For each element of its elements reference, we create a MMElementList!CommonElement. </commentsBefore>
      <commentsBefore>-- Each element of this list is computed via a distinct keyword which creates a CommonElement for each Leaf of a list we compute via an helper.</commentsBefore>
      <outPattern location="26:2-33:4">
        <elements xsi:type="atl:SimpleOutPatternElement" location="27:3-30:4" varName="lstRt">
          <type xsi:type="ocl:OclModelElement" location="27:11-27:36" name="RootElement" model="/1"/>
          <bindings location="28:4-28:19" propertyName="name">
            <value xsi:type="ocl:NavigationOrAttributeCallExp" location="28:12-28:19" name="name">
              <source xsi:type="ocl:VariableExp" location="28:12-28:14" referredVariable="/0/@elements.0/@inPattern/@elements.0"/>
            </value>
          </bindings>
          <bindings location="29:4-29:22" propertyName="elements">
            <value xsi:type="ocl:VariableExp" location="29:16-29:22" referredVariable="/0/@elements.0/@outPattern/@elements.1"/>
          </bindings>
        </elements>
        <elements xsi:type="atl:ForEachOutPatternElement" location="31:3-33:4" varName="elmLst" variableExp="/0/@elements.0/@outPattern/@elements.0/@bindings.1/@value">
          <type xsi:type="ocl:OclModelElement" location="31:21-31:48" name="CommonElement" model="/1"/>
          <bindings location="32:4-32:21" propertyName="name">
            <value xsi:type="ocl:NavigationOrAttributeCallExp" location="32:12-32:21" name="name">
              <source xsi:type="ocl:VariableExp" location="32:12-32:16" referredVariable="/0/@elements.0/@outPattern/@elements.1/@iterator"/>
            </value>
          </bindings>
          <collection xsi:type="ocl:OperationCallExp" location="31:65-31:86" operationName="getLeavesInOrder">
            <source xsi:type="ocl:VariableExp" location="31:65-31:67" referredVariable="/0/@elements.0/@inPattern/@elements.0"/>
          </collection>
          <iterator location="31:57-31:61" varName="leaf" variableExp="/0/@elements.0/@outPattern/@elements.1/@bindings.0/@value/@source"/>
        </elements>
      </outPattern>
      <inPattern location="24:2-25:41">
        <elements xsi:type="atl:SimpleInPatternElement" location="25:3-25:19" varName="rt" variableExp="/0/@elements.0/@inPattern/@filter/@source /0/@elements.0/@outPattern/@elements.0/@bindings.0/@value/@source /0/@elements.0/@outPattern/@elements.1/@collection/@source">
          <commentsBefore>-- should be unique</commentsBefore>
          <type xsi:type="ocl:OclModelElement" location="25:8-25:19" name="Node" model="/2"/>
        </elements>
        <filter xsi:type="ocl:OperationCallExp" location="25:21-25:40" operationName="isTreeNodeRoot">
          <source xsi:type="ocl:VariableExp" location="25:21-25:23" referredVariable="/0/@elements.0/@inPattern/@elements.0"/>
        </filter>
      </inPattern>
    </elements>
  </atl:Module>
  <ocl:OclModel location="12:18-12:31" name="MMElementList" elements="/0/@elements.0/@outPattern/@elements.0/@type /0/@elements.0/@outPattern/@elements.1/@type" model="/0/@outModels.0"/>
  <ocl:OclModel location="12:45-12:51" name="MMTree" elements="/0/@elements.0/@inPattern/@elements.0/@type" model="/0/@inModels.0"/>
</xmi:XMI>
